"""
This class will be used for handling user input and display, and will also be used for all event handling procedures. 
It will be responsible for determining all the valid moves and contain a log of the moves made. 
"""

import sys

import pygame as p 

from chess_engine import ChessEngine
from chess_pieces import Move
from chess_pieces import Piece
from game_methods import Game
from settings import Settings
from chess_ai import ChessAI

class Main:
    def __init__(self):
        #initialization of game, creation of settings and screen object
        self.engine = ChessEngine() #initialize chess engine object
        self.engine_settings = Settings() #initialize settings object
        self.gm = Game() #we create an instance of our game
        
        self.chess_piece = Piece() #creates an instance of our pieces whenever Game object is initialized

        self.sqSelected = ()
        self.playerClicks = [] #keep track of player clicks (two tuples: [(x1, y1), (x2, y2)])

        self.moveMade = False
        self.gameOver = False

        self.smartMove = ChessAI()
        
        p.init() #initialize package
        self.screen = p.display.set_mode((self.engine_settings.WIDTH, self.engine_settings.HEIGHT))
        p.display.set_caption("Pygame Chess")
        self.clock = p.time.Clock()
        self.screen.fill(p.Color(self.engine_settings.BG_COLOR))

    def run_game(self):
        #variables used
        
        chess_piece = self.chess_piece
        engine = self.engine
        engine_settings = self.engine_settings
        gm = self.gm
        smartMove = self.smartMove

        screen = self.screen
        clock = self.clock

        sqSelected = self.sqSelected
        playerClicks = self.playerClicks

        validMoves = engine.getValidMoves(chess_piece, engine)
        moveMade = self.moveMade #flag for checking if a move is made
        gameOver = self.gameOver
        playerOne = True #if a human is playing white, then this will be True. If an AI is playing, then false. 
        playerTwo = False #same as above, but for black 

        gm.load_images(chess_piece, engine_settings) #in the interest of efficiency, we will only load the images once in the program
        #handling of keyboard and mouse events while the game is running
        while True: #while the game is running
            humanTurn = (engine.whiteTurn and playerOne) or (not engine.whiteTurn and playerTwo)
            for event in p.event.get(): #respond to keyclicks and mouse events
                if event.type == p.QUIT:
                    p.quit()
                    sys.exit()
                elif event.type == p.MOUSEBUTTONDOWN: #click
                    if not gameOver and humanTurn: #only allow moves if game is not over
                        position = p.mouse.get_pos() #get position of mouse

                        clicked_col = position[0] // engine_settings.SQSIZE
                        clicked_row = position[1] // engine_settings.SQSIZE
                        
                        if sqSelected == (clicked_row, clicked_col): #if user clicks the same square twice
                            sqSelected = () #deselect square
                            playerClicks = [] #clear player clicks
                        else: 
                            sqSelected = (clicked_row, clicked_col)
                            playerClicks.append(sqSelected) #append for both 1st and 2nd clicks
                        if len(playerClicks) == 2: #after players 2nd click, the board has to display the move
                            move = Move(playerClicks[0], playerClicks[1], engine.board)
                            #we will be adding flags to moves, to indicate whether they are pawn promotions, en passant or castling
                            #when these flags are added, the engine needs to be able to recognize them, 
                            #or the program won't be able to either
                            print(move.getChessNotation(engine))
                            for i in range(len(validMoves)):
                                if move == validMoves[i]:
                                    engine.makeMove(validMoves[i]) #validMove[i] = move generated by engine as opposed to player
                                    moveMade = True
                                    sqSelected = () #reset user clicks
                                    playerClicks = []
                            if not moveMade:
                                #if move is invalid, set current click to current square selected
                                playerClicks = [sqSelected] #like clicking on same square twice, nothing happens
                elif event.type == p.KEYDOWN: #key handler 
                    if event.key == p.K_LEFT: #undo move if left arrow key is pressed
                        engine.undo_move()
                        moveMade = True
            
            #AI move finder
            if not gameOver and not humanTurn:
                AIMove = smartMove.findGreedyMove(chess_piece, engine, validMoves)
                if AIMove is None: #if it can't find best move because of checkmate
                    AIMove = smartMove.findRandomMove(validMoves) #it finds a random one
                engine.makeMove(AIMove)
                moveMade = True

            if moveMade: #when the user makes a valid move, we want to generate a new set of valid moves
                validMoves = engine.getValidMoves(chess_piece, engine)
                moveMade = False

            gm.updateGame(screen, engine, engine_settings, validMoves, sqSelected, chess_piece)
            
            if engine.checkMate:
                gameOver = True
                if engine.whiteTurn:
                    gm.drawText(screen, "Black wins by checkmate", engine_settings)
                else:
                    gm.drawText(screen, "White wins by checkmate", engine_settings)
            
            elif engine.stalemate:
                gameOver = True
                gm.drawText(screen, "Stalemate", engine_settings)
            
            clock.tick(engine_settings.MAX_FPS) #for every second, at most 15 frames should pass
            p.display.flip() #makes the most recently drawn screen visible
            
main = Main()
main.run_game()


    


